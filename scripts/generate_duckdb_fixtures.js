const fs = require('fs');
const path = require('path');

const cases = [
  {
    name: 'basic select',
    sql: "select 1 as a, NULL as b, 'duck' as c",
  },
  {
    name: 'multi row values',
    sql: "select * from (values (1, 'alpha'), (2, NULL), (3, 'gamma')) as t(id, label)",
  },
  {
    name: 'boolean and double',
    sql: 'select true as ok, false as no, 3.5 as pi',
  },
  {
    name: 'bigint extremes',
    sql: 'select cast(9223372036854775807 as BIGINT) as max_bigint, cast(-9223372036854775808 as BIGINT) as min_bigint',
  },
  {
    name: 'simple aggregate',
    sql: 'select count(*) as total, sum(i) as sum from (values (1), (2), (3)) as t(i)',
  },
];

function toCell(value) {
  if (value === null || value === undefined) {
    return { value: '', isNull: true };
  }
  if (typeof value === 'string') {
    return { value, isNull: false };
  }
  if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') {
    return { value: String(value), isNull: false };
  }
  return { value: JSON.stringify(value), isNull: false };
}

function escapeMoonbitString(value) {
  return value
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

function mbtString(value) {
  return `"${escapeMoonbitString(value)}"`;
}

function formatStringArray(values) {
  return `[${values.map(mbtString).join(', ')}]`;
}

function formatBoolArray(values) {
  return `[${values.map((value) => (value ? 'true' : 'false')).join(', ')}]`;
}

function formatStringMatrix(values) {
  return `[${values.map(formatStringArray).join(', ')}]`;
}

function formatBoolMatrix(values) {
  return `[${values.map(formatBoolArray).join(', ')}]`;
}

function formatCase(caseData) {
  return [
    '  {',
    `    name: ${mbtString(caseData.name)},`,
    `    sql: ${mbtString(caseData.sql)},`,
    `    columns: ${formatStringArray(caseData.columns)},`,
    `    rows: ${formatStringMatrix(caseData.rows)},`,
    `    nulls: ${formatBoolMatrix(caseData.nulls)},`,
    '  },',
  ].join('\n');
}

async function main() {
  const api = await import('@duckdb/node-api');
  const instance = await api.DuckDBInstance.create(':memory:');
  const connection = await instance.connect();
  const fixtures = [];

  try {
    for (const entry of cases) {
      const result = await connection.run(entry.sql);
      const columns = result.columnNames();
      const rowsJson = await result.getRowsJson();
      const rows = [];
      const nulls = [];

      for (const row of rowsJson) {
        const values = Array.isArray(row) ? row : columns.map((name) => row[name]);
        const rowValues = [];
        const rowNulls = [];
        for (const value of values) {
          const cell = toCell(value);
          rowValues.push(cell.value);
          rowNulls.push(cell.isNull);
        }
        rows.push(rowValues);
        nulls.push(rowNulls);
      }

      fixtures.push({
        name: entry.name,
        sql: entry.sql,
        columns,
        rows,
        nulls,
      });
    }
  } finally {
    if (connection && typeof connection.close === 'function') {
      await connection.close();
    }
    if (connection && typeof connection.closeSync === 'function') {
      connection.closeSync();
    }
    if (instance && typeof instance.close === 'function') {
      await instance.close();
    }
  }

  const outputPath = path.join(__dirname, '..', 'duckdb_fixture_cases.mbt');
  const lines = [
    '// Generated by scripts/generate_duckdb_fixtures.js. Do not edit by hand.',
    '///|',
    'pub let fixture_cases : Array[FixtureCase] = [',
    fixtures.map(formatCase).join('\n'),
    ']',
    '',
  ];

  fs.writeFileSync(outputPath, lines.join('\n'), 'utf8');
  console.log(`Wrote ${outputPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
